---
title: "Informe preliminar"
author: "Emanuelle Marsella, Maximiliano Saldaña"
date: "16/4/2020"
output:
  pdf_document:
    toc: no
    pandoc_args: [
      "--number-sections",
      "--number-offset=1"
    ]
header-includes:
  - \usepackage{float}
  - \usepackage[spanish]{babel}

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE,
                      include=FALSE,
                      warning = FALSE,
                      message = FALSE,
                      fig.pos = 'H',
                      fig.align = 'center',
                      out.extra = '',
                      fig.hold = 'hold',
                      out.width = "50%"
                      )
options(xtable.comment=FALSE,
        xtable.table.placement="H")
```


```{r, include = FALSE}
library(dplyr)
library(ggplot2)
library(readxl)
library(xtable)
library(FactoMineR)
library(forcats)


```

\title{Proyecto Análisis Multivariado\\ 

\large Análisis Multivariado, UdelaR
}

\author{Emanuelle Marsella, Maximiliano Saldaña}

\date{Junio 2021}


\maketitle



\newpage

\tableofcontents

\newpage


```{r PRUEBA OTRAS BASES, echo=FALSE}

##INTENTO CON OTRAS BASES, IMPUTACION Y REMPLAZO DE VALORES FALTANTES##



# #Lectura de los datos, se incluyen valores de distintas bas.es
# 
# datos <- read.table("corona.txt", sep = "\t", header = TRUE)
# 
# datos <- datos  %>% rename(healthexp= "currenthealthexpenditureofgdpshx", gdppercap = "gdppercapitaconstant2010us" )
# 
# 
# 
# datos_supl <- read_xlsx("bases otras fuentes/owid-covid-data.xlsx")
# 
# datos_supl2 <- datos_supl %>% 
#   mutate(date = as.Date(date)) %>% 
#   filter(date == as.Date("2020-03-31"))
#   
#  
# #verificamos que tenemos los datos de los paises en la base suplementaria
# 
# faltan <- datos$country %in% datos_supl2$location
# datos$country[which(faltan == FALSE)]
# 
# #queremos completar las variables con datos faltantes, usando otra base
# ##estos tienen datos disponibles al 31/03/2020
# datos_supl2$location <-  recode(datos_supl2$location,
#                             `Cape Verde` = "Cabo Verde",
#                             `Congo` = "Congo, R",
#                             `Cote d'Ivoire` = "Cote Ivory",
#                             `Czechia` = "Czech Republic",
#                             `Guinea-Bissau` = "Guinea Bissau",
#                             `Slovakia` = "Slovak Republic"
#                             )
# 
# 
# datos_supl3 <- datos_supl2 %>% filter(location %in% c("Cabo Verde", "Congo, R", "Cote Ivory", "Czech Republic", "Guinea Bissau", "Slovak Republic"))
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# 
# ###Observaciones que le faltan datos del 31/03/2020, remplazamos con la info mas cercana a esa fecha
# 
# nodata<- datos_supl %>% filter(location %in% c("Lesotho", "Tajikistan", "Tonga", "Turkmenistan", "Yemen")) %>%
#   select(location, median_age, gdp_per_capita, hospital_beds_per_thousand, date) %>% 
#   rename(country= "location", medage = "median_age", gdppercap = "gdp_per_capita", hospitalbed = "hospital_beds_per_thousand") %>% 
#   mutate(country = if_else(country == "Tajikistan", "Taijikistan", country)) %>%
#   arrange(date) %>% 
#   group_by(country) %>% 
#   filter(row_number()==1) 
#   
# 
# faltantes <- datos %>% 
#   filter(country %in% c("Lesotho", "Taijikistan", "Tonga", "Turkmenistan", "Yemen" )) %>% 
#   select(-c("medage", "gdppercap", "hospitalbed"))
# 
# 
# nodata <- left_join(nodata, faltantes, by = "country") %>% 
#   mutate(hospitalbed = as.double(hospitalbed)) %>% 
#   select(-date)
# 
# 
# #info de lesotho extraida del banco mundial
# nodata[3,4] <- 1.3 
# 
# 
# ##Ahora unimos estos datos a los datos de la base
# `%nin%` = Negate(`%in%`) 
# 
# datos <- datos %>% 
#   filter(country %nin% c("Lesotho", "Tajikistan", "Tonga", "Turkmenistan", "Yemen")) %>% 
#   select(names(nodata)) %>%
#   rbind(nodata)

```







```{r lectura de datos, echo=FALSE}
#Lectura de los datos

datos <- read.table("corona.txt", sep = "\t", header = TRUE)

datos <- datos  %>% rename(healthexp= "currenthealthexpenditureofgdpshx", gdppercap = "gdppercapitaconstant2010us" )
```



```{r densidad poblacional}
datospob <- read_xls("datospob.xls") %>% 
  select(`Country Name`, `2018`) %>%
  rename(country = `Country Name`, denspob = `2018` )


faltan <- datos$country %in% datos$country
datos$country[which(faltan == FALSE)]


datospob$country <-  recode(datospob$country,
                    `Bahamas, The` = "Bahamas",
                    `Brunei Darussalam` = "Brunei",
                    `Congo, Rep.` = "Congo, R",
                    `Cote d'Ivoire` = "Cote Ivory",
                    `Congo, Dem. Rep.` = "Democratic Republic of Congo",
                    `Egypt, Arab Rep.` = "Egypt",
                    `Gambia, The` = "Gambia",
                    `Guinea-Bissau` = "Guinea Bissau",
                    `Hong Kong SAR, China` = "Hong Kong",
                    `Iran, Islamic Rep.` = "Iran",
                    `Kyrgyz Republic` = "Kyrgyzstan",
                    `Lao PDR` = "Laos",
                    `Russian Federation` = "Russia",
                    `Korea, Rep.` = "South Korea",
                    `Tajikistan` = "Taijikistan",
                    `Yemen, Rep.` = "Yemen"
                    )

#sum(datos$country %in% datospob$country)-length(datos$country %in% datospob$country) control

datos <- datos %>% left_join(datospob, by="country")
```



# Resumen ejecutivo

El objetivo de este trabajo es aplicar las técnicas de Análisis Factorial a la base de datos que surgen del trabajo **Economic Policy Responses to a Pandemic: Developing the COVID-19 Economic Stimulus Index** (Ceyhun Elgin, Gokce Basbug, Abdullah Yalaman; 2020). Se busca reproducir el índice de estímulo económico creado por los autores y  posteriormente utilizar dicho índice para un análisis de componentes principales que involucre a su vez variables de índole sanitaria, económica y demográfica. 




# Descripción de los datos

Los datos disponibles fueron elaborados por los autores a partir de una recopilación de distintas fuentes. La principal es el FMI (Fondo Monetario Internacional), pero algunos datos fueron reemplazados por otros provenientes de páginas gubernamentales o canales de noticias con el fin de que toda la información estuviese actualizada. La información se extiende  hasta el 31 de marzo de 2020.
Además, incluimos por nuestra parte la variable densidad poblacional, con datos extraídos del Banco Mundial actualizados a 2018, pues consideramos que la variable puede ser de interés en el análisis.


```{r nro observaciones, echo =FALSE}
dim(datos)
```
## Observaciones y variables 

Se cuenta con datos para 166 observaciones (países) y 14 variables. Estas últimas son:

\underline{Cuantitativas}

* *fiscal*: paquete de políticas fiscales adoptadas, representado como porcentaje del PBI

* *ratecut*: representa el porcentaje que fue recortado de la tasa de interés en relación a la de febrero de 2020

* *macrofin*: tamaño del paquete de medidas macrofinancieras, expresado como porcentaje del PBI

* *bopgdp*: políticas de balanza de pago, expresadas como porcentaje del PBI

* *totalcases*: cantidad de casos totales de covid-19

* *medage*: edad mediana en el país (a 2019)

* *infectionrate*: tasa de infección, representa la proporción de la población total infectada de covid-19

* *hospitalbed*: camas de hospital por cada 1000 personas

* *healthexp*: gastos en salud, expresados como porcentaje del PBI

* *stringency*: índice de rigurosidad de respuesta gubernamental (desarrollado por Hale y Webster en 2020)

* *gdppercap*: PBI per cápita del país en dólares a niveles de 2010

* *CESI_INDEX*: índice de estímulo económico (construido por los autores utilizando análisis de componentes principles).

* *denspob*: densidad poblacional del país, medida como cantidad de personas por kilómetro cuadrado de área terrestre


\underline{Cualitativas}

* *othermonetary*: variable indicadora que indica si en el país se tomaron otras medidas monetarias

* *otherbp*: variable indicadora que indica si en el país se tomaron otras medidas de políticas de balanza de pago


## Datos faltantes

```{r, results='asis', include=TRUE}
cbind("Variable"=names(datos), "Nº de NA's"=NAcheck <- as.numeric(apply(is.na(datos), 2, sum))) %>% 
  as.data.frame %>% 
  filter(`Nº de NA's`!=0) %>% 
  t() %>%
    xtable(caption="Tabla de cantidad de observaciones faltables para las variables.") %>% 
  print.xtable(include.colnames = FALSE)

datos <- datos %>% select(-c(stringency))

```



```{r imputacion, echo=FALSE}

dim(datos)
(NAcheck <- as.numeric(apply(is.na(datos), 2, sum)))

#Hay NAs en varias variables, una opcion de imputacion, en las cuantitativas imputar la media y en las cualitativas el modo. Stringency tiene 93 NAs (evaluar sacarla)

#vector de valores medios

vals_meds <- rep(0, dim(datos)[2])

for(j in 1:dim(datos)[2]){
  
  vals_meds[j] <- mean(datos[,j], na.rm = TRUE)
}

#imputacion de vals medios en NAs

for(j in 1:dim(datos)[2]){
  if(NAcheck[j]>0){
    
    for(i in 1:dim(datos)[1]){
      if(is.na(datos[i,j])==TRUE){
       datos[i,j] <- vals_meds[j] 
    }
    }
  }
}


```

En primer lugar se aprecia que varias de las variables cuentan con datos faltantes, en particular las variables *total cases*, *medage*, *gpdpercapitaconstant2010us*, *healthexp*, *hospitalbed*, *stringency* e *infectionrate*. Para poder trabajar con las técnicas de análisis factorial es necesario que contemos con todos los datos, por lo que se tiene que considerar un método para imputar los valores faltantes. Una alternativa posible para el caso de las variables cuantitativas es imputar el valor medio de la variable cuando no contemos con el valor de dicha variable para una observación, opción por la cual optamos por su simplicidad y al no ser el foco del presente trabajo. Para el caso de las variables cualitativas una alternativa de imputación es emplear el modo de la variable cada vez que haya un dato faltante, pero en este caso no es necesario ya que no hay datos faltantes en las variables cualitativas.


Debe destacarse que la variable *stringency* cuenta con 93 valores faltantes en las 166 observaciones, por lo que se tomó la decisión de dejar esta variable de lado para no emplear una variable cuya mayoría de valores serían imputados, a pesar de que los autores la emplearon para su análisis.



## Análisis de correlaciones

```{r correlaciones, include=TRUE, results='asis'}

correl <- datos %>% select(-c(country, othermonetary, otherbop, CESI_INDEX)) %>% cor()

correl %>% round(2) %>%  xtable(caption="Matriz de correlaciones") %>% print.xtable(include.rownames = FALSE)

```

Se destacan por ser altas las correlaciones entre *gdppercapita* y *fiscal* (`r correl["gdppercap", "fiscal"]`), *medage* y *gpdpercap* y entre *medage* y *hospitalbed*. Al realizar el análisis de componentes principales se buscará obtener un nuevo conjunto de variables incorrelacionadas entre si y posiblemente reducir su número con respecto al conjunto original.

## Observación preliminar de valores atípicos

Se realiza un sondeo de los valores atípicos de las variables, porque pueden afectar el ACP al confundirse las relaciones entre las variables. Esto se llama efecto tamaño, donde los valores atípicos causan que haya una estructura común al conjunto de variables que termina por ser expresada en la primer componente principal, al estar las proyecciones de las variables próximas entre sí.

<!-- pregutar en consulta este concepto  -->

```{r, results='asis'}
datos %>% arrange(desc(bopgdp)) %>% head(11) %>% select(country, bopgdp) %>% xtable(caption = "Tabla de medidas de balanza de pago como porcentaje de PBI, ordenada de forma decreciente.")

```

En la tabla anterior podemos ver que solo hay 10 países que tomaron medidas de balanza de pago de este primer tipo, siendo Argelia el país que efectuo mayor cantidad de estas medidas como porcentaje de su PBI. 

```{r}
summary(as.factor(datos$otherbop))
```
Vemos que solo 32 países tomaron alguna otra medida de balanza de pagos, y los restantes 134 no lo hicieron.


```{r}
boxplot(datos$fiscal)

datos %>% select(country, fiscal) %>% arrange(fiscal) %>% head(1)

datos %>% filter(country!="Algeria") %>% select(fiscal) %>% boxplot()


```
Vemos que Argelia, que era la observación que tenía el mayor valor de la variable *bopgdp*, es también la observación que tiene el menor valor de la variable *fiscal*.


```{r}
boxplot(datos$ratecut)

datos %>% select(country, ratecut) %>% arrange(desc(ratecut)) %>% head(20)

datos %>% filter(ratecut < 0) %>% count()
datos %>% filter(ratecut == 0) %>% count()


bigote <- quantile(datos$ratecut, 0.75)+ 1.5*IQR(datos$ratecut)

datos %>% filter(ratecut > bigote) %>% count()

```



Para la variable *ratecut* la mediana resulta cercana a 0, lo cual se deriva del hecho de que 95 países no experimentaron cambios en su tasa de interés, mientras que 5 tuvieron un aumento de la misma. Hay un conjunto de 21 países que superan el límite extremo superior (40% de disminución de la tasa de interés) y podrían ser considerados como atípicos. Entre estas observaciones se encuentran Estados Unidos, Reino Unido, Noruega, Croacia, Nueva Zelanda. Estados Unidos es el único país que tuvo una reducción del 100%.  



```{r}
boxplot(datos$macrofin)
```

Para la variable *macrofin* hay dos observaciones que se alejan incluso más que el resto de las atípicas, tomando valores próximos a 25, siendo que las siguientes observaciones más altas están en torno a 15. Estas dos observaciones con valores altos corresponden a los países Baréin y Oman.


```{r}
hist(datos$macrofin, breaks = 25)

datos %>% filter(macrofin == 0) %>% count()
```

Cabe destacar que hay un conjunto de 102 países cuyo gasto en medidas macrofinancieras representó un 0% del PBI.





```{r}
datos %>% filter(bopgdp == 0) %>% count()
```

Considerando la variable bopgdp la mayoría de las observaciones tienen valor 0. Luego está Argelia que tiene el valor más alto próximo a 6, y las dos siguientes con valores próximos a 3 son Croacia y Suiza.


```{r}
boxplot(datos$gdppercap)
```


La variable gdppercap hay bastante dispersión como es de esperarse y un conjunto pequeño de países con valores altos de la variable. Las observaciones que toman los mayores valores son Luxemburgo, Noruega y Suiza. 

```{r}
datos %>% select(country, gdppercap) %>% arrange(desc(gdppercap)) %>% head(3)
```


## Foco en variables sanitarias



```{r}

boxplot(datos$medage)

datos[which.max(datos$medage),]
datos[which.min(datos$medage),]



boxplot(datos$healthexp)

datos[which.max(datos$healthexp),]

```

Al considerar las variables de caracter sanitarias-demográficas, se destaca una observación atípica en cuanto a la variable *healthexp*, el gasto en salud como porcentaje del PBI, que corresponde a Estados Unidos. En cuanto a la edad mediana, el rango intercuartílico va de los 25 a los 40 años aproximadente y la edad mediana mínima es de 15 años (Correspondiente a Nigeria) y la edad mediana máxima es de 48 años (correspondiete a Japón).


```{r}
boxplot(datos$hospitalbed)


datos %>% select(country, hospitalbed) %>% arrange(desc(hospitalbed)) %>% head(10)


```

Considerando la variable *hospitalbed*, se aprecia que Japón, Corea del Sur y Bielorusia se separan del resto de los países por su mayor cantidad de camas de hospital cada 1000 habitantes.


```{r}
boxplot(datos$infectionrate)

quantile(datos$infectionrate, 0.75)
datos %>% select(country, infectionrate) %>% arrange(desc(infectionrate)) %>% head(20)

```

En cuanto a la tasa de infección respecto a la población (*infectionrate*), se observa en el gráfico que hay una grán acumulación de tasas de infección en torno a valores próximos a 0 y un 75% de las tasas son menores a 0.00025 (que representa un caso por cada 4000 habitantes aproximadamente). Se distinguen especialmente del resto de los países San Marino, Islandia y Luxemburgo. Aquí puede estar entrando en juego que dichos países cuentan con poblaciones muy reducidas, poblacionales acumuladas en ciudades y en el caso de San Marino y Luxemburgo, limítrofes con países que también contaban con tasas de infección altas (el primero con Italia y el segundo con Bélgica y Alemania). En particular, San Marino tiene una tasa de infección de 0.0068 que representa un caso por cada 150 habitantes aproximadamente.



# Aplicación del Análisis de Componentes Principales

## Construcción del Índice de Estímulo Económico 

Inicialmente, intentaremos replicar el índice de estímulo económico elaborado por los autores del artículo. Para esto, realizamos un análisis de componentes principales únicamente con las variables de índole económico *fiscal*, *ratecut*, *macrofin*, *bopgdp*, *othermonetary* y *otherbop*.

```{r}
vars.indice <- c("fiscal", "ratecut", "macrofin", "bopgdp", "othermonetary", "otherbop")

acp_indice <- PCA(select(datos, vars.indice), ncp=6)

summary(acp_indice)

ind.est.econ <- acp_indice$ind$coord[,1]

cor(ind.est.econ, datos$CESI_INDEX)

sum(ind.est.econ-datos$CESI_INDEX) #Llegamos a que son el mismo índice

#No coinciden los componentes de las variables con los que presentan los autores en el artículo. # PREGUNTAR

```

Se puede apreciar que el Índice de Estímulo Económico que se obtuvo realizando el ACP y definiéndolo como los valores de la primera componente principal es equivalente al obtenido por los autores. Esto nos lleva a pensar que el procedimiento de imputación de valores faltantes fue el mismo, la imputación de la media de las variables.


```{r}
acp_indice$eig
```

La primer componente, que se toma para definir el índice, explica un 27,13% de la inercia total. No representa un porcentaje a nuestro juicio alto, pero en pos de seguir la línea de trabajo de los autores del artículo se trabajará con esta nueva variable como síntesis de las medidas económicas tomadas por los países, definiéndolo como el índice de estimulo económico (*CESI_INDEX*).

Al realizar el Análisis de Componentes Principales desde la perspectiva de la nube de variables, se proyecta el conjunto de variables en el subespacio $W$ de dimensión  $k \le J$, de forma tal de minimizar la inercia del subespacio, ya que esta representa la variabilidad de la nube de puntos original que no queda explicada por el subespacio.

Esto se logra representando esta nueva nube de puntos en un conjunto de ejes $(\Delta_1, ..., \Delta_J)$ que se construye como combinación lineal de los vectores de una base ortonormal del subespacio, $W$, formada por los vectores propios asociados a la matriz $X^TDXM$ (siendo $X$ la matriz de datos, $D$ la matriz de métrica y $M$ la matriz de pesos de las variables). Las componentes principales son los coeficientes que permiten expresar a las variables como combinación lineal de los vectores propios ortonormales de esa base. La inercia del subespacio se minimiza eligiendo una base ortnonormal conformada por los $k$ vectores propios asociados a los $k$ valores propios de mayor magnitud.

Así, es claro que cada coeficiente representa la correlación entre la variable asociada y el eje sobre el que se está proyectando, dado que si el valor de la variable aumenta en una unidad, el valor en el eje aumenta en una cantidad proporcional al coeficiente.


```{r, include=TRUE, results='asis'}
#plot.PCA(acp_indice, choix = "var")

summary(acp_indice)

acp_indice$var$coord[,1] %>% as.data.frame %>% xtable(caption="Correlación de cada variable con el índice de estímulo económico.")


```

Podemos observar en la tabla anterior la correlación de cada una de las variables utilizadas en el análisis de componentes principales con el índice de estímulo económico definido. Las correlaciones, que nos permiten medir la calidad de representación de cada variable en el primer eje, resultan ser altas y con signo positivo para las variables *fiscal* y *macrofin*, lo cual significa que las medidas de tipo fiscal y macrofinanciero tienen un impacto positivo en el índice de estímulo económico construido.

Las variables *ratecut* y *othermonetary* tienen correlaciones menores a las variables previamente mencionadas, y de signo positivo, lo cual parece indicar que las otras medidas de tipo monetaria, así como también las medidas de reducción de tasa de interés, también tienen un impacto positivo en el índice de estímulo económico, si bien la magnitud de las correlaciones no son lo suficientemente altas como para poder afirmarlo.

Por su parte, las variables asociadas a medidas de políticas de balanza de pago *bopgdp* y *otherbop* tienen correlaciones bajas, lo cual significa que no influyen demasiado en la construcción del índice de estímulo económico y por lo tanto no están bien representadas por el mismo.


## Análisis de Componentes Principales considerando el Índice de Estímulo Económico 

A continuación, se procede a emplear esta nueva variable en un análisis de componentes principales. Como primer paso, creamos a partir de *infectionrate* la variable *noinfectionrate*, para indicar la proporción de habitantes del país no infectados en lugar de los infectados. Esto lo hacemos con la intención de que al realizar análisis de componentes principales y potencialmente crear un índice que resuma el comportamiento de país frente a la pandemia, un valor elevado de esta variable tenga un efecto positivo sobre el valor que toma el país en el índice en lugar de uno negativo. El conjunto de variables empleado en este análisis esta conformado inicialmente por: *medage*, *gdppercap*, *healthexp*, *hospitalbed*, *noinfectionrate* y *CESI_INDEX*. No se consideran las variables empleadas para crear el índice de estímulo económico y tampoco la variable que indica la cantidad de casos totales de COVID-19 (*totalcases*), ya que la información ya se expresa en la variable *noinfectionrate* y además al estar medida en términos absolutos dificulta la comparación entre observaciones. Adicionalmente se hizo la prueba de incluir una variable que expresaba la densidad poblacional de los países, pero se concluyó que la misma no aportaba al análisis. Estos resultados se encuentran en el anexo.

*preguntar en la consulta la parte *

### Primer Análisis

**Perspectiva de la Nube de Variables**

Se realiza un procedimiento análogo al explicado en la sección anterior para obtener las componentes principales en el conjunto de variables considerado.

```{r, include=TRUE, results='asis'}
datos$noinfectionrate <- 1-datos$infectionrate

datos$CESI_INDEX2 <- ind.est.econ


#ANEXO vars.acp2 <- c("medage", "gdppercap", "healthexp", "hospitalbed", "noinfectionrate", "CESI_INDEX2", "denspob")

#ANEXO acp2 <- PCA(datos[,vars.acp2], ncp=7)



vars.acp3 <- c("medage", "gdppercap", "healthexp", "hospitalbed", "noinfectionrate", "CESI_INDEX2")

acp3 <- PCA(datos[,vars.acp3], ncp=7)

acp3$eig %>% round(2) %>%  as.data.frame() %>% rename(`Valor propio`="eigenvalue", `% de varianza`= "percentage of variance", `% acumulado de varianza`="cumulative percentage of variance") %>% xtable(caption="Valores propios asociados a las componentes principales y porcentajes de inercia de cada uno.")

#gdppercap y cesi colineales porque probablemente los coeficientes son iguales

#Rlos angulos de noinfectionrate y de hospitalbed son muy parecidos con el eje 2

```

En la tabla anterior podemos ver que la primer componente principal logra explicar un 50.37% de la variabilidad de la nube de puntos, y la segunda componente principal un 16.59%. Esto significa que con el primer plano principal logramos explicar prácticamente un 67% de la variabilidad total. Incluyendo la tercer componente principal este porcentaje asciende a casi 80% de la variabilidad explicada, una cantidad muy importante a nuestro juicio dado que tan solo incluimos la mitad de las variables de la matriz de datos.


```{r}
plot.PCA(acp3, axes= c(1,2), choix = c("var"))

#ver como interpretar la ""colinealidad"" entre infectionrate y gdppercap en el primer plano principal
```

En el grafico anterior podemos ver representados los vectores asociados a las variables proyectadas en el primer plano principal, teniendo en cuenta que el largo del vector en relación al círculo unitario indica qué tan bien está representada esa variable en el primer plano principal. Podemos ver que en general los vectores son relativamente largos, destacándose las variables *medage*, *hospitalbed*, *noinfectionrate* y *gdppercap*.

A excepción de *healthexp*, notamos que todas las variables "necesitan" de ambos ejes para poder estar bien representadas.
<!-- Ver bien como podemos ver esto numericamente, sobre todo para poder descartar que no pase lo mismo con healthexp por ejemplo -->

Además, vemos que todas las variables apuntan en la misma dirección del primer componente principal a excepción de *noinfectionrate* que apunta en sentido contrario. Esto quiere decir que un aumento en *noinfectionrate* lleva a una disminución del valor de la primera componente, mientras que un aumento en cualquiera de las demás variables lleva a un aumento en dicho componente.


```{r, include=TRUE, results='asis'}
acp3$var$coord %>% round(2) %>% as.data.frame() %>% select(Dim.1, Dim.2) %>% 
  xtable(caption="Coordenadas de las variables originales en el primer plano principal")

# acp3$var$cos2 %>% round(2) %>% as.data.frame() %>% select(Dim.1, Dim.2) %>%
#   xtable(caption="cos2 de los ángulos de las variables con los ejes del primer plano principal")

#CONSULTAR

```

En el cuadro anterior se puede ver que las variables *medage* y *gdppercap* tienen una correlación alta (en torno a 0,8) con la primera componente principal, lo cual ya veíamos en el gráfico anterior dado que los vectores tienen una longitud considerable y apuntan en la dirección de esta componente. Vemos también que sucede lo contrario con *noinfectionrate*, dado que tiene una correlación negativa con la primer componente principal lo cual veíamos en la dirección.

En cuanto a la componente 2, se aprecia que con *medage* y *gdppercap* tiene la misma correlación, aunque una con signo positivo y la otra con signo negativo. Esto es fácil de ver en el gráfico, dado que los dos vectores tienen la misma longitud y ángulos opuestos respecto a este eje.  También se ve que la componente 2 es en el primer plano principal la que contribuye en mayor medida a explicar la variable *infectionrate*, puesto que la correlación es mayor (0,63). Por otro lado las correlaciones de las demás variables con esta componente son en general más bajas que con la componente 1, lo cual significa que no representa esas variables tan bien como el otro eje.

Como resultado a destacar de este primer análisis, no se llegó a que los dos primeros ejes tengan cada uno una interpretación clara, es decir, que explique cada uno un tipo de variable. Un resultado que ejemplifica esto es que la variable *noinfectionrate* está bien explicada por los dos primeros ejes en su conjunto pero no existe uno que la caracterice individualmente, dado que es la variable de mayor interés y resultaría deseable ver como se relaciona el resto de las variables con un eje que la caracteriza.




**Perspectiva de la Nube de Individuos**

\underline{\textbf{Describir teóricamente}}


```{r}
summary(acp3)


plot.PCA(acp3, choix = "ind", habillage="cos2")

#steam_ncp sirve para estimar la cantidad de componentes con la cual quedarse
```
En el gráfico anterior, podemos observar las proyecciones de los individuos en el primer plano principal, los cuales se encuentran coloreados en función del $cos^2(\theta)$, es decir, el coseno al cuadrado del ángulo que forman los vectores originales de los individuos con este plano. Un $cos^2(\theta)$ próximo a 0 significa que el ángulo $theta$ está próximo a un múltiplo de $\pi/2$, es decir, es casi ortogonal al plano, y en consecuencia el punto no se encuentra bien explicado por el mismo. Por otro lado, un $cos^2(\theta)$ próximo a 1 signfica que el punto original es casi colineal con el plano y que por lo tanto se encuentra bien explicado, y la proyección es buena.

Es deseable que ninguno de los individuos sea especialmente influyente a la hora de generar los componentes principales. Esa situación no deseada se da cuando el punto es lejano al baricentro y además el $cos^2(\theta)$ es próximo a 0. Podemos ver en el gráfico que esta situación no se da, puesto que hay un conjunto de puntos con $cos^2(\theta)$ próximos a 0 pero se encuentran cerca del baricentro; mientras que también hay un conjunto de puntos que se encuentran más apartados del baricentro, pero con $cos^2(\theta)$ relativamente altos.

<!-- #####TABLA####### consultar como se hace -->

La idea es que con la tabla vemos los valores numericos de los cos2 y que para los que tienen norma alta, los cos2 son bajos y por lo tanto no hay observaciones influyentes.

\underline{\textbf{La idea es que con la tabla vemos los valores numericos de los cos2 y que para los que tienen norma alta, los cos2 son bajos y por lo tanto no hay observaciones influyentes.}}






### Segundo Análisis

**Perspectiva de la Nube de Variables**

Se realiza un nuevo análisis de componentes principales, esta vez eliminando la variable *medage* 

```{r, include=TRUE, results='asis'}
vars.acp4 <- c("healthexp", "medage", "noinfectionrate", "CESI_INDEX2", "hospitalbed")

acp4 <- PCA(datos[,vars.acp4], ncp=7)

# acp3$eig %>% round(2) %>%  as.data.frame() %>% rename(`Valor propio`="eigenvalue", `% de varianza`= "percentage of variance", `% acumulado de varianza`="cumulative percentage of variance") %>% xtable(caption="Valores propios asociados a las componentes principales y porcentajes de inercia de cada uno.")

#gdppercap y cesi colineales porque probablemente los coeficientes son iguales

#Rlos angulos de noinfectionrate y de hospitalbed son muy parecidos con el eje 2
```


```{r, include=TRUE, results='asis'}
plot.PCA(acp3, axes= c(1,3), choix = c("var"))
```



```{r}
vars.acp4 <- c( "gdppercap", "healthexp", "hospitalbed", "noinfectionrate", "CESI_INDEX2")

acp4 <- PCA(datos[,vars.acp4], ncp=7)

summary(acp4)
```



```{r}
vars.acp5 <- c("medage", "healthexp", "hospitalbed", "noinfectionrate", "CESI_INDEX2")

acp5 <- PCA(datos[,vars.acp5], ncp=7)

summary(acp5)
```



```{r}
#AL hacer indice de salud, considerar cambios de escala
```

